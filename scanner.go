package injector

import (
	"debug/pe"
	"errors"
)

const (
	jmpInstSize    = 5
	expInstSizeX86 = 7
	expInstSizeX64 = 12
	expCaveSizeX86 = expInstSizeX86 + jmpInstSize
	expCaveSizeX64 = expInstSizeX64 + jmpInstSize
)

type codeCave struct {
	virtualAddr  uint32
	pointerToRaw uint32
	size         int
}

func (c *codeCave) Write(img, data []byte) {
	if len(data) > c.size {
		panic("data length is grater than code cave size")
	}
	copy(img[c.pointerToRaw:], data)
}

func (inj *Injector) scanCodeCave() ([]*codeCave, error) {
	// search the first section with RX
	var text *pe.Section
	for idx, section := range inj.img.Sections {
		char := section.SectionHeader.Characteristics
		if char&0x00000020 == 0 { // contains code
			continue
		}
		if char&0x20000000 == 0 { // executable
			continue
		}
		if char&0x40000000 == 0 { // readable
			continue
		}
		text = section
		// when the first section is RX, we can try to extend
		if idx == 0 {
			inj.canTryExtend = true
		}
		break
	}
	if text == nil {
		return nil, errors.New("cannot find RX section in image")
	}
	// record offset and calculate scan range
	size := text.Size
	if text.VirtualSize < size {
		size = text.VirtualSize
	}
	if size < 32*1024 {
		return nil, errors.New("RX section too small")
	}
	section, err := text.Data()
	if err != nil {
		return nil, err
	}
	section = section[:size-32]
	return inj.scanSection(section, text.VirtualAddress, text.Offset), nil
}

// #nosec G115
func (inj *Injector) scanSection(section []byte, va, raw uint32) []*codeCave {
	var expCaveSize int
	switch inj.arch {
	case "386":
		expCaveSize = expCaveSizeX86
	case "amd64":
		expCaveSize = expCaveSizeX64
	}
	var (
		address int
		reserve int
		caves   []*codeCave
	)
	for address < len(section) {
		b := section[address]
		switch b {
		case 0x00:
			// ignore padding data in the tail of section data
			address++
			continue
		case 0xAA, 0xAB:
			// ignore stosb, stosd instruction group.
			// these instructions are usually generated by the
			// compiler to achieve efficient bulk memory filling
			address++
			continue
		case 0xCC:
			reserve = 2
		default:
			reserve = 5
		}
		expSize := reserve + expCaveSize
		caveSize := 1
		for j := address + 1; j < len(section); j++ {
			if section[j] != b {
				break
			}
			caveSize++
			if caveSize == expSize {
				break
			}
		}
		if caveSize == expSize {
			caves = append(caves, &codeCave{
				virtualAddr:  va + uint32(address+reserve),
				pointerToRaw: raw + uint32(address+reserve),
				size:         caveSize - reserve,
			})
		}
		address += caveSize
	}
	return caves
}
